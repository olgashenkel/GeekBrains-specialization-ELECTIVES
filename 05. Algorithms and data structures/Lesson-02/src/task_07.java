/*
Сортировка кучей (пирамидальная)
Особенность данной сортировки в использовании дополнительной структуры
данных называемой бинарной кучей (пирамидой).
Бинарная куча представляет из себя древовидную структуру, когда у каждого
объекта может быть до 2 детей. При этом строится из массива она предельно
просто – первый элемент массива является корнем, 2 и 3 его детьми, 4 и 5 детьми
элемента 2 и т.д. пока в массиве остаются элементы.

Благодаря такому подходу к составлению бинарной кучи она получает следующее
свойство: если принять элемент с индексом i за родителя, то индексы его дочерних
элементов будут 2 * i + 1 и 2 * i + 2.
Таким образом, несмотря на то, что сортировка использует для своего алгоритма
бинарную кучу, в реальности строить никакую отдельную структуру данных не
нужно, т.к. мы в любой момент можем определить детей для каждого из элементов
и проводить их сравнение или обмен.
Общая идея сортировки пирамидой заключается в том, что сравнение элементов
происходит не между всеми элементами массива, а только в пределах построенной
пирамидальной структуры, т.е. родителя и его детей. Такая операция называется
«просеиванием», когда интересующий нас узел кучи сравнивается со своими
двумя детьми и меняется местами с тем, что больше родителя. Если оба ребенка
больше родителя – обмен происходит с наибольшим из детей.
Дальше необходимо определить алгоритм, в каком порядке необходимо проводить
операции просеивания. Для этого весь процесс пирамидальной сортировки делится
на 2 этапа.
Первый этап – это подготовка кучи. Определяем правую часть кучи по формуле
n/2-1, где n – длина массива. Начиная с указанного индекса, мы начинаем операции
просеивания в цикле до тех пор, пока не придем к началу массива. В результате
этой операции самый большой элемент нашего массива окажется в индексе 0, что
является вершиной пирамиды.

Второй этап – начинается с того, что первый и последний элемент массива
меняется местами, тем самым наибольший элемент оказывается в конце массива,
а текущая вершина (индекс 0) начинает операцию просеивания по пирамиде с
размером n-1, в результате чего снова наибольший элемент займет 0 индекс нашего
массива. Меняем его местами с предпоследним элементом массива (последний мы
уже определи) и повторяем операцию. Это происходит до тех пор, пока все
элементы массива не займут свое место, а размер пирамиды для просеивания не
уменьшится до 0.
В данном случае мы имеем обратную, в отличие от быстрой сортировки,
зависимость на сложность алгоритма – внешний цикл содержит O(n) шагов, а
вложенный работает по уже знакомому нам принципу O(log n), т.к. количество
операций соответствует обходу вложенных элементов, что суммарно дает нам
сложность O(n log n), как и у быстрой сортировки.

 */


public class task_07 {

    public static void sort(int[] array){
        //Построение кучи (перегруппируем массив)
        for (int i = array.length/2-1; i >= 0; i--) {
            heapify(array, array.length, i);
        }

        //Один за другим извлекаем элементы из кучи
        for (int i = array.length-1; i >= 0; i--) {
            //Перемещаем текущий корень в конец
            int temp = array[0];;
            array[0] = array[i];
            array[i] = temp;

            //Вызываем процедуру heapify на уменьшенной куче
            heapify(array, i, 0);
        }
    }

    private static void heapify(int[] array, int heapSize, int rootIndex){
        int largest = rootIndex; // Инициализируем наибольший элемент как корень
        int leftChild = 2*rootIndex+1; // левый = 2*rootIndex + 1
        int rightChild = 2*rootIndex+2; // правый = 2*rootIndex + 2

        //Если левый дочерний элемент больше корня
        if (leftChild < heapSize && array[leftChild]>array[largest]){
            largest = leftChild;
        }

        // Если правый дочерний элемент больше, чем самый большой элемент на данный момент
        if (rightChild < heapSize && array[rightChild] > array[largest]){
            largest = rightChild;
        }

        // Если самый большой элемент не корень
        if (largest != rootIndex){
            int temp = array[rootIndex];
            array[rootIndex] = array[largest];
            array[largest] = temp;

            // Рекурсивно преобразуем в двоичную кучу затронутое поддерево
            heapify(array, heapSize, largest);
        }
    }

    public static void main(String[] args) {
        int[] array = new int[]{4, 2, 5, 8, 1, 9, 2, 3, 6, 8, 5};

        sort(array);

        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

}
