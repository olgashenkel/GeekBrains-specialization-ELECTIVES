/* Алгоритмы поиска

Бинарный поиск - тип поискового алгоритма, который последовательно
делит пополам заранее отсортированный массив данных, чтобы обнаружить
нужный элемент. Другие его названия — двоичный поиск, метод половинного
деления, дихотомия. Принцип работы алгоритма бинарного поиска. Основная
последовательность действий алгоритма выглядит так: Сортируем массив
данных. Делим его пополам и находим середину.

Бинарный поиск - O(log n)

Этот алгоритм использует сортировку массива для пропуска большей части данных
при поиске. Бинарный поиск начинается с середины массива, где сразу получает
данные в какой части массива может находится искомый элемент – если
центральный элемент массива меньше искомого – значит искомый в правой части
массива. Если больше – значит в левой. Далее применяется аналогичная проверка
для выбранной половины данных, снова через сравнение центрального элемента
отрезка.

Таким образом, при поиске элемента количество операций сравнения будет
существенно меньше, чем в операции поиска перебором. Более того, т.к. мы
оперирует центральным элементом отрезка, чтобы сделать всего на 1 шаг больше
нам необходимо увеличить количество элементов самого массива вдвое, чтобы
центральный элемент массива оказался центральным для правой или левой части
массива. Это яркий пример логарифмической сложности алгоритма O(log n). Таким
образом, один раз потратив время на сортировку данных мы можем во много раз
сократить временные затраты на многократный поиск в дальнейшем.
Благодаря особенности данного алгоритма его очень просто записать с помощью
рекурсии – операция сравнения абсолютно идентичная для любого из вложенных
шагов.

Сложность этого алгоритма – O(log n). И вложенная логика, которая требует
сравнить элемент с искомым и определить куда двигаться дальше – вправо или
влево. Данный алгоритм имеет сложность O(1), т.к. эта операция никак не зависит от
размера массива и, по сути, оперирует всегда с 1 значением. Перемножение
сложностей дает нам O(1 * log n) => O(log n). Подход, используемый бинарным
поиском, разделяющий объем данных пополам на каждом шаге, называется
«разделяй и властвуй». Он позволяет создавать алгоритмы со сложностями O(m *
log n), где m может быть как константой (непосредственно бинарный поиск), так и
непосредственно n. Зачастую такие алгоритмы сложнее, но гораздо выгоднее с
точки зрения производительности, т.к. дают сложность ощутимо меньше, чем O(n2).
Это подводит нас к алгоритмам сортировки, основанным на подобном принципе.
 */


public class task_05 {

    public static int binarySorch(int[] array, int value, int min, int max) {
        int midpoint;
        if (max < min) {
            return -1;
        } else {
            midpoint = (max - min) / 2 + min;
        }

        if (array[midpoint] < value) {
            return binarySorch(array, value, midpoint + 1, max);
        } else {
            if (array[midpoint] > value) {
                return binarySorch(array, value, min, midpoint - 1);
            } else {
                return midpoint;
            }
        }
    }


    public static void main(String[] args) {
        int[] array = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9};

        System.out.println(binarySorch(array, 8, 0, array.length - 1));
    }

}
