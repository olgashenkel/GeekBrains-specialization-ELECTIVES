from socket import socket, AF_INET, SOCK_STREAM, gethostbyname
import argparse
from queue import Queue
import threading
import nmap


'''
Установка тестов TCP-соединения

Функция tcp_test, которая пытается установить TCP-соединение с указанным портом на целевом IP-адресе. 
Она устанавливает таймаут, чтобы избежать длительных ожиданий на каждом порте, 
и использует connect_ex для попытки установить соединение.

Если connect_ex возвращает 0, это означает, что соединение установлено успешно, 
то есть порт открыт, и функция выводит сообщение с указанием открытого порта
'''
def tcp_test(port: int, target_ip: str) -> None:
    with socket(AF_INET, SOCK_STREAM) as sock:
        sock.settimeout(1)
        result = sock.connect_ex(target_ip, port)
        if result == 0:
            print(f'Открытый порт: {port}')



'''
Настройка параллельных проверок портов

Далее мы создадим функцию worker, которая будет использоваться каждым потоком для 
обработки портов из очереди и использовать функцию tcp_test для проверки статуса каждого порта.

Функция worker предназначена для выполнения несколькими потоками. 
Она непрерывно извлекает номера портов из очереди и использует ранее определенную функцию tcp_test 
для проверки, открыт ли этот порт на целевом IP.

После проверки порта она отмечает задачу как выполненную в очереди. 
Эта функция позволяет параллельно сканировать порты, значительно ускоряя процесс
'''

def worker(target_ip: str, queue: Queue) -> None:
    while not queue.empty():
        port = queue.get()
        tcp_test(port, target_ip)
        queue.task_done()



'''
Организация процесса сканирования

Функция main организует процесс сканирования, настраивая очередь, 
инициализируя рабочие потоки и управляя операцией сканирования в указанном диапазоне портов.

Функция main организует весь процесс сканирования портов.

Она сначала преобразует целевой доменное имя в IP-адрес, затем создает очередь для номеров портов, 
которые будут сканироваться. Она заполняет очередь всеми портами в указанном диапазоне 
и запускает несколько рабочих потоков (100 в этом примере), которые параллельно обрабатывают очередь, 
проверяя каждый порт. Функция ожидает, пока все порты будут обработаны (queue.join()), 
и затем выводит сообщение о том, что сканирование завершено.
'''

def main(host: str, start_port: int, end_port: int) -> None:
    target_ip = gethostbyname(host)
    queue = Queue()
    for port in range(start_port, end_port + 1):
        queue.put(port)
    for _ in range(100):
        t = threading.Thread(target=worker, args=(target_ip, queue,))
        t.daemon = True
        t.start()
    queue.join()
    print("Сканирование завершено.")



'''
Запуск сканера портов
Наконец, настало время запустить наш сканер портов. 
Мы будем сканировать диапазон портов на локальном компьютере, чтобы протестировать нашу утилиту.

В этом коде используется разбор аргументов командной строки для скрипта сканера портов, 
что делает его более гибким и удобным для пользователя.

С помощью библиотеки argparse определяются два обязательных аргумента: host и ports.

Аргумент host предназначен для указания адреса или имени хоста целевого объекта, 
который вы хотите сканировать.
Аргумент ports ожидает строку, которая определяет диапазон портов для сканирования, 
заданный в формате "start-end" (например, "5000-8000"), который скрипт разделяет на start_port 
и end_port с использованием разделителя - и затем преобразует их в целые числа. 
Это позволяет пользователям легко указать целевой объект и диапазон портов 
при запуске скрипта из командной строки.
'''

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='TCP Port Scanner')
    parser.add_argument('host', help='Host to scan')
    parser.add_argument('ports', help='Port range to scan, formatted as start-end')
    args = parser.parse_args()

    start_port, end_port = map(int, args.ports.split('-'))
    main(args.host, start_port, end_port)